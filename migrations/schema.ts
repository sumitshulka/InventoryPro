import { pgTable, check, serial, text, numeric, boolean, timestamp, index, foreignKey, integer, unique, varchar, json } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const approvalSettings = pgTable("approval_settings", {
	id: serial().primaryKey().notNull(),
	requestType: text("request_type").default('issue').notNull(),
	minApprovalLevel: text("min_approval_level").default('manager').notNull(),
	maxAmount: numeric("max_amount"),
	requiresSecondApproval: boolean("requires_second_approval").default(false).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	check("approval_settings_id_not_null", sql`NOT NULL id`),
	check("approval_settings_request_type_not_null", sql`NOT NULL request_type`),
	check("approval_settings_min_approval_level_not_null", sql`NOT NULL min_approval_level`),
	check("approval_settings_requires_second_approval_not_null", sql`NOT NULL requires_second_approval`),
	check("approval_settings_is_active_not_null", sql`NOT NULL is_active`),
	check("approval_settings_created_at_not_null", sql`NOT NULL created_at`),
]);

export const issues = pgTable("issues", {
	id: serial().primaryKey().notNull(),
	title: text().notNull(),
	description: text().notNull(),
	category: text().default('general').notNull(),
	priority: text().default('medium').notNull(),
	status: text().default('open').notNull(),
	reportedBy: integer("reported_by").notNull(),
	assignedTo: integer("assigned_to"),
	warehouseId: integer("warehouse_id"),
	itemId: integer("item_id"),
	attachments: text().array(),
	estimatedResolutionDate: timestamp("estimated_resolution_date", { mode: 'string' }),
	actualResolutionDate: timestamp("actual_resolution_date", { mode: 'string' }),
	resolutionNotes: text("resolution_notes"),
	closedBy: integer("closed_by"),
	closedAt: timestamp("closed_at", { mode: 'string' }),
	reopenedBy: integer("reopened_by"),
	reopenedAt: timestamp("reopened_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("issues_assigned_to_idx").using("btree", table.assignedTo.asc().nullsLast().op("int4_ops")),
	index("issues_category_idx").using("btree", table.category.asc().nullsLast().op("text_ops")),
	index("issues_closed_by_idx").using("btree", table.closedBy.asc().nullsLast().op("int4_ops")),
	index("issues_created_at_idx").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("issues_priority_idx").using("btree", table.priority.asc().nullsLast().op("text_ops")),
	index("issues_reopened_by_idx").using("btree", table.reopenedBy.asc().nullsLast().op("int4_ops")),
	index("issues_reported_by_idx").using("btree", table.reportedBy.asc().nullsLast().op("int4_ops")),
	index("issues_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("issues_warehouse_idx").using("btree", table.warehouseId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.reportedBy],
			foreignColumns: [users.id],
			name: "issues_reported_by_users_id_fk"
		}),
	foreignKey({
			columns: [table.assignedTo],
			foreignColumns: [users.id],
			name: "issues_assigned_to_users_id_fk"
		}),
	foreignKey({
			columns: [table.warehouseId],
			foreignColumns: [warehouses.id],
			name: "issues_warehouse_id_warehouses_id_fk"
		}),
	foreignKey({
			columns: [table.itemId],
			foreignColumns: [items.id],
			name: "issues_item_id_items_id_fk"
		}),
	foreignKey({
			columns: [table.closedBy],
			foreignColumns: [users.id],
			name: "issues_closed_by_users_id_fk"
		}),
	foreignKey({
			columns: [table.reopenedBy],
			foreignColumns: [users.id],
			name: "issues_reopened_by_users_id_fk"
		}),
	check("issues_id_not_null", sql`NOT NULL id`),
	check("issues_title_not_null", sql`NOT NULL title`),
	check("issues_description_not_null", sql`NOT NULL description`),
	check("issues_category_not_null", sql`NOT NULL category`),
	check("issues_priority_not_null", sql`NOT NULL priority`),
	check("issues_status_not_null", sql`NOT NULL status`),
	check("issues_reported_by_not_null", sql`NOT NULL reported_by`),
	check("issues_created_at_not_null", sql`NOT NULL created_at`),
	check("issues_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const categories = pgTable("categories", {
	id: serial().primaryKey().notNull(),
	name: text().notNull(),
	description: text(),
}, (table) => [
	unique("categories_name_unique").on(table.name),
	check("categories_id_not_null", sql`NOT NULL id`),
	check("categories_name_not_null", sql`NOT NULL name`),
]);

export const departments = pgTable("departments", {
	id: serial().primaryKey().notNull(),
	name: text().notNull(),
	description: text(),
	managerId: integer("manager_id"),
	isActive: boolean("is_active").default(true).notNull(),
}, (table) => [
	index("departments_active_idx").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("departments_manager_idx").using("btree", table.managerId.asc().nullsLast().op("int4_ops")),
	unique("departments_name_unique").on(table.name),
	check("departments_id_not_null", sql`NOT NULL id`),
	check("departments_name_not_null", sql`NOT NULL name`),
	check("departments_is_active_not_null", sql`NOT NULL is_active`),
]);

export const emailSettings = pgTable("email_settings", {
	id: serial().primaryKey().notNull(),
	provider: text().notNull(),
	displayName: text("display_name").notNull(),
	host: text(),
	port: integer(),
	secure: boolean().default(false),
	username: text(),
	password: text(),
	fromEmail: text("from_email").notNull(),
	fromName: text("from_name").notNull(),
	isActive: boolean("is_active").default(false).notNull(),
	isVerified: boolean("is_verified").default(false).notNull(),
	verificationTestEmail: text("verification_test_email"),
	lastTestedAt: timestamp("last_tested_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("email_settings_active_idx").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("email_settings_provider_idx").using("btree", table.provider.asc().nullsLast().op("text_ops")),
	index("email_settings_verified_idx").using("btree", table.isVerified.asc().nullsLast().op("bool_ops")),
	check("email_settings_id_not_null", sql`NOT NULL id`),
	check("email_settings_provider_not_null", sql`NOT NULL provider`),
	check("email_settings_display_name_not_null", sql`NOT NULL display_name`),
	check("email_settings_from_email_not_null", sql`NOT NULL from_email`),
	check("email_settings_from_name_not_null", sql`NOT NULL from_name`),
	check("email_settings_is_active_not_null", sql`NOT NULL is_active`),
	check("email_settings_is_verified_not_null", sql`NOT NULL is_verified`),
	check("email_settings_created_at_not_null", sql`NOT NULL created_at`),
	check("email_settings_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const inventory = pgTable("inventory", {
	id: serial().primaryKey().notNull(),
	itemId: integer("item_id").notNull(),
	warehouseId: integer("warehouse_id").notNull(),
	quantity: integer().default(0).notNull(),
	lastUpdated: timestamp("last_updated", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("inventory_item_idx").using("btree", table.itemId.asc().nullsLast().op("int4_ops")),
	index("inventory_item_warehouse_idx").using("btree", table.itemId.asc().nullsLast().op("int4_ops"), table.warehouseId.asc().nullsLast().op("int4_ops")),
	index("inventory_last_updated_idx").using("btree", table.lastUpdated.asc().nullsLast().op("timestamp_ops")),
	index("inventory_quantity_idx").using("btree", table.quantity.asc().nullsLast().op("int4_ops")),
	index("inventory_warehouse_idx").using("btree", table.warehouseId.asc().nullsLast().op("int4_ops")),
	check("inventory_id_not_null", sql`NOT NULL id`),
	check("inventory_item_id_not_null", sql`NOT NULL item_id`),
	check("inventory_warehouse_id_not_null", sql`NOT NULL warehouse_id`),
	check("inventory_quantity_not_null", sql`NOT NULL quantity`),
	check("inventory_last_updated_not_null", sql`NOT NULL last_updated`),
]);

export const auditLogs = pgTable("audit_logs", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	action: text().notNull(),
	entityType: text("entity_type").notNull(),
	entityId: integer("entity_id"),
	details: text().notNull(),
	oldValues: text("old_values"),
	newValues: text("new_values"),
	ipAddress: text("ip_address"),
	userAgent: text("user_agent"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "audit_logs_user_id_users_id_fk"
		}),
	check("audit_logs_id_not_null", sql`NOT NULL id`),
	check("audit_logs_user_id_not_null", sql`NOT NULL user_id`),
	check("audit_logs_action_not_null", sql`NOT NULL action`),
	check("audit_logs_entity_type_not_null", sql`NOT NULL entity_type`),
	check("audit_logs_details_not_null", sql`NOT NULL details`),
	check("audit_logs_created_at_not_null", sql`NOT NULL created_at`),
]);

export const locations = pgTable("locations", {
	id: serial().primaryKey().notNull(),
	name: text().notNull(),
	address: text().notNull(),
	city: text().notNull(),
	state: text().notNull(),
	zipCode: text("zip_code").notNull(),
	country: text().default('India').notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("locations_active_idx").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("locations_city_idx").using("btree", table.city.asc().nullsLast().op("text_ops")),
	index("locations_country_idx").using("btree", table.country.asc().nullsLast().op("text_ops")),
	index("locations_created_at_idx").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("locations_state_idx").using("btree", table.state.asc().nullsLast().op("text_ops")),
	unique("locations_name_unique").on(table.name),
	check("locations_id_not_null", sql`NOT NULL id`),
	check("locations_name_not_null", sql`NOT NULL name`),
	check("locations_address_not_null", sql`NOT NULL address`),
	check("locations_city_not_null", sql`NOT NULL city`),
	check("locations_state_not_null", sql`NOT NULL state`),
	check("locations_zip_code_not_null", sql`NOT NULL zip_code`),
	check("locations_country_not_null", sql`NOT NULL country`),
	check("locations_is_active_not_null", sql`NOT NULL is_active`),
	check("locations_created_at_not_null", sql`NOT NULL created_at`),
]);

export const licenses = pgTable("licenses", {
	id: serial().primaryKey().notNull(),
	applicationId: text("application_id").notNull(),
	clientId: text("client_id").notNull(),
	licenseKey: text("license_key").notNull(),
	subscriptionType: text("subscription_type").notNull(),
	validTill: timestamp("valid_till", { mode: 'string' }).notNull(),
	mutualKey: text("mutual_key").notNull(),
	checksum: text().notNull(),
	subscriptionData: text("subscription_data").notNull(),
	baseUrl: text("base_url").notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	lastValidated: timestamp("last_validated", { mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }),
}, (table) => [
	index("licenses_active_idx").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("licenses_application_idx").using("btree", table.applicationId.asc().nullsLast().op("text_ops")),
	index("licenses_client_idx").using("btree", table.clientId.asc().nullsLast().op("text_ops")),
	index("licenses_last_validated_idx").using("btree", table.lastValidated.asc().nullsLast().op("timestamp_ops")),
	index("licenses_valid_till_idx").using("btree", table.validTill.asc().nullsLast().op("timestamp_ops")),
	unique("licenses_license_key_unique").on(table.licenseKey),
	check("licenses_id_not_null", sql`NOT NULL id`),
	check("licenses_application_id_not_null", sql`NOT NULL application_id`),
	check("licenses_client_id_not_null", sql`NOT NULL client_id`),
	check("licenses_license_key_not_null", sql`NOT NULL license_key`),
	check("licenses_subscription_type_not_null", sql`NOT NULL subscription_type`),
	check("licenses_valid_till_not_null", sql`NOT NULL valid_till`),
	check("licenses_mutual_key_not_null", sql`NOT NULL mutual_key`),
	check("licenses_checksum_not_null", sql`NOT NULL checksum`),
	check("licenses_subscription_data_not_null", sql`NOT NULL subscription_data`),
	check("licenses_base_url_not_null", sql`NOT NULL base_url`),
	check("licenses_is_active_not_null", sql`NOT NULL is_active`),
	check("licenses_last_validated_not_null", sql`NOT NULL last_validated`),
	check("licenses_created_at_not_null", sql`NOT NULL created_at`),
]);

export const notifications = pgTable("notifications", {
	id: serial().primaryKey().notNull(),
	senderId: integer("sender_id").notNull(),
	recipientId: integer("recipient_id").notNull(),
	subject: text().notNull(),
	message: text().notNull(),
	category: text().default('general').notNull(),
	priority: text().default('normal').notNull(),
	status: text().default('unread').notNull(),
	parentId: integer("parent_id"),
	relatedEntityType: text("related_entity_type"),
	relatedEntityId: integer("related_entity_id"),
	isArchived: boolean("is_archived").default(false).notNull(),
	archivedAt: timestamp("archived_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("notifications_category_idx").using("btree", table.category.asc().nullsLast().op("text_ops")),
	index("notifications_created_at_idx").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("notifications_recipient_idx").using("btree", table.recipientId.asc().nullsLast().op("int4_ops")),
	index("notifications_sender_idx").using("btree", table.senderId.asc().nullsLast().op("int4_ops")),
	index("notifications_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.senderId],
			foreignColumns: [users.id],
			name: "notifications_sender_id_users_id_fk"
		}),
	foreignKey({
			columns: [table.recipientId],
			foreignColumns: [users.id],
			name: "notifications_recipient_id_users_id_fk"
		}),
	check("notifications_id_not_null", sql`NOT NULL id`),
	check("notifications_sender_id_not_null", sql`NOT NULL sender_id`),
	check("notifications_recipient_id_not_null", sql`NOT NULL recipient_id`),
	check("notifications_subject_not_null", sql`NOT NULL subject`),
	check("notifications_message_not_null", sql`NOT NULL message`),
	check("notifications_category_not_null", sql`NOT NULL category`),
	check("notifications_priority_not_null", sql`NOT NULL priority`),
	check("notifications_status_not_null", sql`NOT NULL status`),
	check("notifications_is_archived_not_null", sql`NOT NULL is_archived`),
	check("notifications_created_at_not_null", sql`NOT NULL created_at`),
	check("notifications_updated_at_not_null", sql`NOT NULL updated_at`),
]);

export const organizationSettings = pgTable("organization_settings", {
	id: serial().primaryKey().notNull(),
	organizationName: text("organization_name").default('My Organization').notNull(),
	logo: text(),
	currency: text().default('USD').notNull(),
	currencySymbol: text("currency_symbol").default('$').notNull(),
	timezone: text().default('UTC').notNull(),
	defaultUnits: text("default_units").array().default(["pcs", "boxes", "reams", "kg", "liters"]).notNull(),
	allowedCategories: text("allowed_categories").array().default(["Electronics", ""Office Supplies"", "Furniture"]).notNull(),
	inventoryValuationMethod: text("inventory_valuation_method").default('Last Value').notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }),
}, (table) => [
	check("organization_settings_id_not_null", sql`NOT NULL id`),
	check("organization_settings_organization_name_not_null", sql`NOT NULL organization_name`),
	check("organization_settings_currency_not_null", sql`NOT NULL currency`),
	check("organization_settings_currency_symbol_not_null", sql`NOT NULL currency_symbol`),
	check("organization_settings_timezone_not_null", sql`NOT NULL timezone`),
	check("organization_settings_default_units_not_null", sql`NOT NULL default_units`),
	check("organization_settings_allowed_categories_not_null", sql`NOT NULL allowed_categories`),
	check("organization_settings_inventory_valuation_method_not_null", sql`NOT NULL inventory_valuation_method`),
	check("organization_settings_created_at_not_null", sql`NOT NULL created_at`),
]);

export const requestApprovals = pgTable("request_approvals", {
	id: serial().primaryKey().notNull(),
	requestId: integer("request_id").notNull(),
	approverId: integer("approver_id").notNull(),
	approvalLevel: text("approval_level").notNull(),
	status: text().default('pending').notNull(),
	comments: text(),
	approvedAt: timestamp("approved_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	check("request_approvals_id_not_null", sql`NOT NULL id`),
	check("request_approvals_request_id_not_null", sql`NOT NULL request_id`),
	check("request_approvals_approver_id_not_null", sql`NOT NULL approver_id`),
	check("request_approvals_approval_level_not_null", sql`NOT NULL approval_level`),
	check("request_approvals_status_not_null", sql`NOT NULL status`),
	check("request_approvals_created_at_not_null", sql`NOT NULL created_at`),
]);

export const requestItems = pgTable("request_items", {
	id: serial().primaryKey().notNull(),
	requestId: integer("request_id").notNull(),
	itemId: integer("item_id").notNull(),
	quantity: integer().notNull(),
}, (table) => [
	index("request_items_item_idx").using("btree", table.itemId.asc().nullsLast().op("int4_ops")),
	index("request_items_request_idx").using("btree", table.requestId.asc().nullsLast().op("int4_ops")),
	index("request_items_request_item_idx").using("btree", table.requestId.asc().nullsLast().op("int4_ops"), table.itemId.asc().nullsLast().op("int4_ops")),
	check("request_items_id_not_null", sql`NOT NULL id`),
	check("request_items_request_id_not_null", sql`NOT NULL request_id`),
	check("request_items_item_id_not_null", sql`NOT NULL item_id`),
	check("request_items_quantity_not_null", sql`NOT NULL quantity`),
]);

export const requests = pgTable("requests", {
	id: serial().primaryKey().notNull(),
	requestCode: text("request_code").notNull(),
	userId: integer("user_id").notNull(),
	warehouseId: integer("warehouse_id").notNull(),
	status: text().default('pending').notNull(),
	priority: text().default('normal').notNull(),
	justification: text(),
	notes: text(),
	submittedAt: timestamp("submitted_at", { mode: 'string' }).defaultNow().notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }),
}, (table) => [
	index("requests_created_at_idx").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("requests_priority_idx").using("btree", table.priority.asc().nullsLast().op("text_ops")),
	index("requests_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("requests_submitted_at_idx").using("btree", table.submittedAt.asc().nullsLast().op("timestamp_ops")),
	index("requests_updated_at_idx").using("btree", table.updatedAt.asc().nullsLast().op("timestamp_ops")),
	index("requests_user_idx").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	index("requests_user_status_idx").using("btree", table.userId.asc().nullsLast().op("int4_ops"), table.status.asc().nullsLast().op("text_ops")),
	index("requests_warehouse_idx").using("btree", table.warehouseId.asc().nullsLast().op("int4_ops")),
	index("requests_warehouse_status_idx").using("btree", table.warehouseId.asc().nullsLast().op("int4_ops"), table.status.asc().nullsLast().op("int4_ops")),
	unique("requests_request_code_unique").on(table.requestCode),
	check("requests_id_not_null", sql`NOT NULL id`),
	check("requests_request_code_not_null", sql`NOT NULL request_code`),
	check("requests_user_id_not_null", sql`NOT NULL user_id`),
	check("requests_warehouse_id_not_null", sql`NOT NULL warehouse_id`),
	check("requests_status_not_null", sql`NOT NULL status`),
	check("requests_priority_not_null", sql`NOT NULL priority`),
	check("requests_submitted_at_not_null", sql`NOT NULL submitted_at`),
	check("requests_created_at_not_null", sql`NOT NULL created_at`),
]);

export const rejectedGoods = pgTable("rejected_goods", {
	id: serial().primaryKey().notNull(),
	transferId: integer("transfer_id").notNull(),
	itemId: integer("item_id").notNull(),
	quantity: integer().notNull(),
	rejectionReason: text("rejection_reason").notNull(),
	rejectedBy: integer("rejected_by").notNull(),
	rejectedAt: timestamp("rejected_at", { mode: 'string' }).defaultNow().notNull(),
	warehouseId: integer("warehouse_id").notNull(),
	status: text().default('rejected').notNull(),
	notes: text(),
}, (table) => [
	check("rejected_goods_id_not_null", sql`NOT NULL id`),
	check("rejected_goods_transfer_id_not_null", sql`NOT NULL transfer_id`),
	check("rejected_goods_item_id_not_null", sql`NOT NULL item_id`),
	check("rejected_goods_quantity_not_null", sql`NOT NULL quantity`),
	check("rejected_goods_rejection_reason_not_null", sql`NOT NULL rejection_reason`),
	check("rejected_goods_rejected_by_not_null", sql`NOT NULL rejected_by`),
	check("rejected_goods_rejected_at_not_null", sql`NOT NULL rejected_at`),
	check("rejected_goods_warehouse_id_not_null", sql`NOT NULL warehouse_id`),
	check("rejected_goods_status_not_null", sql`NOT NULL status`),
]);

export const transactions = pgTable("transactions", {
	id: serial().primaryKey().notNull(),
	transactionCode: text("transaction_code").notNull(),
	itemId: integer("item_id").notNull(),
	quantity: integer().notNull(),
	transactionType: text("transaction_type").notNull(),
	sourceWarehouseId: integer("source_warehouse_id"),
	destinationWarehouseId: integer("destination_warehouse_id"),
	requestId: integer("request_id"),
	userId: integer("user_id").notNull(),
	requesterId: integer("requester_id"),
	status: text().default('completed').notNull(),
	cost: numeric({ precision: 10, scale:  2 }),
	rate: numeric({ precision: 10, scale:  2 }),
	supplierName: text("supplier_name"),
	poNumber: text("po_number"),
	deliveryChallanNumber: text("delivery_challan_number"),
	checkInDate: timestamp("check_in_date", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	completedAt: timestamp("completed_at", { mode: 'string' }),
}, (table) => [
	index("transactions_check_in_date_idx").using("btree", table.checkInDate.asc().nullsLast().op("timestamp_ops")),
	index("transactions_completed_at_idx").using("btree", table.completedAt.asc().nullsLast().op("timestamp_ops")),
	index("transactions_created_at_idx").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("transactions_dest_warehouse_idx").using("btree", table.destinationWarehouseId.asc().nullsLast().op("int4_ops")),
	index("transactions_item_idx").using("btree", table.itemId.asc().nullsLast().op("int4_ops")),
	index("transactions_item_warehouse_idx").using("btree", table.itemId.asc().nullsLast().op("int4_ops"), table.sourceWarehouseId.asc().nullsLast().op("int4_ops")),
	index("transactions_request_idx").using("btree", table.requestId.asc().nullsLast().op("int4_ops")),
	index("transactions_requester_idx").using("btree", table.requesterId.asc().nullsLast().op("int4_ops")),
	index("transactions_source_warehouse_idx").using("btree", table.sourceWarehouseId.asc().nullsLast().op("int4_ops")),
	index("transactions_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("transactions_type_idx").using("btree", table.transactionType.asc().nullsLast().op("text_ops")),
	index("transactions_type_user_idx").using("btree", table.transactionType.asc().nullsLast().op("int4_ops"), table.userId.asc().nullsLast().op("int4_ops")),
	index("transactions_user_idx").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	unique("transactions_transaction_code_unique").on(table.transactionCode),
	check("transactions_id_not_null", sql`NOT NULL id`),
	check("transactions_transaction_code_not_null", sql`NOT NULL transaction_code`),
	check("transactions_item_id_not_null", sql`NOT NULL item_id`),
	check("transactions_quantity_not_null", sql`NOT NULL quantity`),
	check("transactions_transaction_type_not_null", sql`NOT NULL transaction_type`),
	check("transactions_user_id_not_null", sql`NOT NULL user_id`),
	check("transactions_status_not_null", sql`NOT NULL status`),
	check("transactions_created_at_not_null", sql`NOT NULL created_at`),
]);

export const transferNotifications = pgTable("transfer_notifications", {
	id: serial().primaryKey().notNull(),
	requestId: integer("request_id").notNull(),
	warehouseId: integer("warehouse_id").notNull(),
	itemId: integer("item_id").notNull(),
	requiredQuantity: integer("required_quantity").notNull(),
	availableQuantity: integer("available_quantity").default(0).notNull(),
	status: text().default('pending').notNull(),
	notifiedUserId: integer("notified_user_id"),
	transferId: integer("transfer_id"),
	notes: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	resolvedAt: timestamp("resolved_at", { mode: 'string' }),
}, (table) => [
	check("transfer_notifications_id_not_null", sql`NOT NULL id`),
	check("transfer_notifications_request_id_not_null", sql`NOT NULL request_id`),
	check("transfer_notifications_warehouse_id_not_null", sql`NOT NULL warehouse_id`),
	check("transfer_notifications_item_id_not_null", sql`NOT NULL item_id`),
	check("transfer_notifications_required_quantity_not_null", sql`NOT NULL required_quantity`),
	check("transfer_notifications_available_quantity_not_null", sql`NOT NULL available_quantity`),
	check("transfer_notifications_status_not_null", sql`NOT NULL status`),
	check("transfer_notifications_created_at_not_null", sql`NOT NULL created_at`),
]);

export const warehouseOperators = pgTable("warehouse_operators", {
	id: serial().primaryKey().notNull(),
	userId: integer("user_id").notNull(),
	warehouseId: integer("warehouse_id").notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("warehouse_operators_active_idx").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("warehouse_operators_created_at_idx").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("warehouse_operators_user_idx").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	index("warehouse_operators_warehouse_idx").using("btree", table.warehouseId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "warehouse_operators_user_id_users_id_fk"
		}),
	foreignKey({
			columns: [table.warehouseId],
			foreignColumns: [warehouses.id],
			name: "warehouse_operators_warehouse_id_warehouses_id_fk"
		}),
	check("warehouse_operators_id_not_null", sql`NOT NULL id`),
	check("warehouse_operators_user_id_not_null", sql`NOT NULL user_id`),
	check("warehouse_operators_warehouse_id_not_null", sql`NOT NULL warehouse_id`),
	check("warehouse_operators_is_active_not_null", sql`NOT NULL is_active`),
	check("warehouse_operators_created_at_not_null", sql`NOT NULL created_at`),
]);

export const users = pgTable("users", {
	id: serial().primaryKey().notNull(),
	username: text().notNull(),
	password: text().notNull(),
	name: text().notNull(),
	email: text().notNull(),
	role: text().default('user').notNull(),
	managerId: integer("manager_id"),
	warehouseId: integer("warehouse_id"),
	departmentId: integer("department_id"),
	isWarehouseOperator: boolean("is_warehouse_operator").default(false).notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	resetToken: text("reset_token"),
	resetTokenExpiry: text("reset_token_expiry"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("users_active_idx").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("users_created_at_idx").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("users_department_idx").using("btree", table.departmentId.asc().nullsLast().op("int4_ops")),
	index("users_email_idx").using("btree", table.email.asc().nullsLast().op("text_ops")),
	index("users_manager_idx").using("btree", table.managerId.asc().nullsLast().op("int4_ops")),
	index("users_reset_token_idx").using("btree", table.resetToken.asc().nullsLast().op("text_ops")),
	index("users_role_idx").using("btree", table.role.asc().nullsLast().op("text_ops")),
	index("users_warehouse_idx").using("btree", table.warehouseId.asc().nullsLast().op("int4_ops")),
	index("users_warehouse_operator_idx").using("btree", table.isWarehouseOperator.asc().nullsLast().op("bool_ops")),
	unique("users_username_unique").on(table.username),
	check("users_id_not_null", sql`NOT NULL id`),
	check("users_username_not_null", sql`NOT NULL username`),
	check("users_password_not_null", sql`NOT NULL password`),
	check("users_name_not_null", sql`NOT NULL name`),
	check("users_email_not_null", sql`NOT NULL email`),
	check("users_role_not_null", sql`NOT NULL role`),
	check("users_is_warehouse_operator_not_null", sql`NOT NULL is_warehouse_operator`),
	check("users_is_active_not_null", sql`NOT NULL is_active`),
	check("users_created_at_not_null", sql`NOT NULL created_at`),
]);

export const warehouses = pgTable("warehouses", {
	id: serial().primaryKey().notNull(),
	name: text().notNull(),
	locationId: integer("location_id").notNull(),
	managerId: integer("manager_id"),
	capacity: integer().notNull(),
	isActive: boolean("is_active").default(true).notNull(),
	status: text().default('active').notNull(),
	deletedAt: timestamp("deleted_at", { mode: 'string' }),
}, (table) => [
	index("warehouses_active_idx").using("btree", table.isActive.asc().nullsLast().op("bool_ops")),
	index("warehouses_deleted_at_idx").using("btree", table.deletedAt.asc().nullsLast().op("timestamp_ops")),
	index("warehouses_location_idx").using("btree", table.locationId.asc().nullsLast().op("int4_ops")),
	index("warehouses_manager_idx").using("btree", table.managerId.asc().nullsLast().op("int4_ops")),
	index("warehouses_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	foreignKey({
			columns: [table.locationId],
			foreignColumns: [locations.id],
			name: "warehouses_location_id_locations_id_fk"
		}),
	foreignKey({
			columns: [table.managerId],
			foreignColumns: [users.id],
			name: "warehouses_manager_id_users_id_fk"
		}),
	unique("warehouses_name_unique").on(table.name),
	check("warehouses_id_not_null", sql`NOT NULL id`),
	check("warehouses_name_not_null", sql`NOT NULL name`),
	check("warehouses_location_id_not_null", sql`NOT NULL location_id`),
	check("warehouses_capacity_not_null", sql`NOT NULL capacity`),
	check("warehouses_is_active_not_null", sql`NOT NULL is_active`),
	check("warehouses_status_not_null", sql`NOT NULL status`),
]);

export const items = pgTable("items", {
	id: serial().primaryKey().notNull(),
	name: text().notNull(),
	sku: text().notNull(),
	description: text(),
	minStockLevel: integer("min_stock_level").default(10).notNull(),
	categoryId: integer("category_id"),
	unit: text().default('pcs').notNull(),
	status: text().default('active').notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	index("items_category_idx").using("btree", table.categoryId.asc().nullsLast().op("int4_ops")),
	index("items_created_at_idx").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("items_min_stock_idx").using("btree", table.minStockLevel.asc().nullsLast().op("int4_ops")),
	index("items_name_idx").using("btree", table.name.asc().nullsLast().op("text_ops")),
	index("items_status_idx").using("btree", table.status.asc().nullsLast().op("text_ops")),
	index("items_unit_idx").using("btree", table.unit.asc().nullsLast().op("text_ops")),
	unique("items_sku_unique").on(table.sku),
	check("items_id_not_null", sql`NOT NULL id`),
	check("items_name_not_null", sql`NOT NULL name`),
	check("items_sku_not_null", sql`NOT NULL sku`),
	check("items_min_stock_level_not_null", sql`NOT NULL min_stock_level`),
	check("items_unit_not_null", sql`NOT NULL unit`),
	check("items_status_not_null", sql`NOT NULL status`),
	check("items_created_at_not_null", sql`NOT NULL created_at`),
]);

export const issueActivities = pgTable("issue_activities", {
	id: serial().primaryKey().notNull(),
	issueId: integer("issue_id").notNull(),
	userId: integer("user_id").notNull(),
	action: text().notNull(),
	previousValue: text("previous_value"),
	newValue: text("new_value"),
	comment: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	description: text(),
}, (table) => [
	index("issue_activities_action_idx").using("btree", table.action.asc().nullsLast().op("text_ops")),
	index("issue_activities_created_at_idx").using("btree", table.createdAt.asc().nullsLast().op("timestamp_ops")),
	index("issue_activities_issue_idx").using("btree", table.issueId.asc().nullsLast().op("int4_ops")),
	index("issue_activities_user_idx").using("btree", table.userId.asc().nullsLast().op("int4_ops")),
	foreignKey({
			columns: [table.issueId],
			foreignColumns: [issues.id],
			name: "issue_activities_issue_id_issues_id_fk"
		}),
	foreignKey({
			columns: [table.userId],
			foreignColumns: [users.id],
			name: "issue_activities_user_id_users_id_fk"
		}),
	check("issue_activities_id_not_null", sql`NOT NULL id`),
	check("issue_activities_issue_id_not_null", sql`NOT NULL issue_id`),
	check("issue_activities_user_id_not_null", sql`NOT NULL user_id`),
	check("issue_activities_action_not_null", sql`NOT NULL action`),
	check("issue_activities_created_at_not_null", sql`NOT NULL created_at`),
]);

export const transferUpdates = pgTable("transfer_updates", {
	id: serial().primaryKey().notNull(),
	transferId: integer("transfer_id").notNull(),
	updatedBy: integer("updated_by").notNull(),
	status: text().notNull(),
	updateType: text("update_type").notNull(),
	description: text(),
	metadata: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
}, (table) => [
	check("transfer_updates_id_not_null", sql`NOT NULL id`),
	check("transfer_updates_transfer_id_not_null", sql`NOT NULL transfer_id`),
	check("transfer_updates_updated_by_not_null", sql`NOT NULL updated_by`),
	check("transfer_updates_status_not_null", sql`NOT NULL status`),
	check("transfer_updates_update_type_not_null", sql`NOT NULL update_type`),
	check("transfer_updates_created_at_not_null", sql`NOT NULL created_at`),
]);

export const transfers = pgTable("transfers", {
	id: serial().primaryKey().notNull(),
	transferCode: text("transfer_code").notNull(),
	sourceWarehouseId: integer("source_warehouse_id").notNull(),
	destinationWarehouseId: integer("destination_warehouse_id").notNull(),
	initiatedBy: integer("initiated_by").notNull(),
	approvedBy: integer("approved_by"),
	status: text().default('pending').notNull(),
	transferMode: text("transfer_mode").default('courier').notNull(),
	expectedShipmentDate: timestamp("expected_shipment_date", { mode: 'string' }),
	expectedArrivalDate: timestamp("expected_arrival_date", { mode: 'string' }),
	actualShipmentDate: timestamp("actual_shipment_date", { mode: 'string' }),
	actualArrivalDate: timestamp("actual_arrival_date", { mode: 'string' }),
	courierName: text("courier_name"),
	trackingNumber: text("tracking_number"),
	receiptNumber: text("receipt_number"),
	handoverPersonName: text("handover_person_name"),
	handoverPersonContact: text("handover_person_contact"),
	handoverDate: timestamp("handover_date", { mode: 'string' }),
	receiptDocument: text("receipt_document"),
	receivedBy: integer("received_by"),
	receivedDate: timestamp("received_date", { mode: 'string' }),
	receiverNotes: text("receiver_notes"),
	overallCondition: text("overall_condition").default('good'),
	notes: text(),
	returnReason: text("return_reason"),
	returnCourierName: text("return_courier_name"),
	returnTrackingNumber: text("return_tracking_number"),
	returnShippedDate: timestamp("return_shipped_date", { mode: 'string' }),
	returnDeliveredDate: timestamp("return_delivered_date", { mode: 'string' }),
	disposalReason: text("disposal_reason"),
	disposalDate: timestamp("disposal_date", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow().notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }),
}, (table) => [
	unique("transfers_transfer_code_unique").on(table.transferCode),
	check("transfers_id_not_null", sql`NOT NULL id`),
	check("transfers_transfer_code_not_null", sql`NOT NULL transfer_code`),
	check("transfers_source_warehouse_id_not_null", sql`NOT NULL source_warehouse_id`),
	check("transfers_destination_warehouse_id_not_null", sql`NOT NULL destination_warehouse_id`),
	check("transfers_initiated_by_not_null", sql`NOT NULL initiated_by`),
	check("transfers_status_not_null", sql`NOT NULL status`),
	check("transfers_transfer_mode_not_null", sql`NOT NULL transfer_mode`),
	check("transfers_created_at_not_null", sql`NOT NULL created_at`),
]);

export const session = pgTable("session", {
	sid: varchar().primaryKey().notNull(),
	sess: json().notNull(),
	expire: timestamp({ precision: 6, mode: 'string' }).notNull(),
}, (table) => [
	index("IDX_session_expire").using("btree", table.expire.asc().nullsLast().op("timestamp_ops")),
	check("session_sid_not_null", sql`NOT NULL sid`),
	check("session_sess_not_null", sql`NOT NULL sess`),
	check("session_expire_not_null", sql`NOT NULL expire`),
]);

export const disposedItems = pgTable("disposed_items", {
	id: serial().primaryKey().notNull(),
	itemId: integer("item_id").notNull(),
	warehouseId: integer("warehouse_id").notNull(),
	quantity: integer().notNull(),
	unitValue: numeric("unit_value", { precision: 10, scale:  2 }).notNull(),
	totalValue: numeric("total_value", { precision: 10, scale:  2 }).notNull(),
	disposalDate: timestamp("disposal_date", { mode: 'string' }).defaultNow().notNull(),
	disposalReason: text("disposal_reason"),
	approvedBy: integer("approved_by").notNull(),
	sourceType: varchar("source_type", { length: 50 }),
	sourceId: integer("source_id"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
}, (table) => [
	check("disposed_items_id_not_null", sql`NOT NULL id`),
	check("disposed_items_item_id_not_null", sql`NOT NULL item_id`),
	check("disposed_items_warehouse_id_not_null", sql`NOT NULL warehouse_id`),
	check("disposed_items_quantity_not_null", sql`NOT NULL quantity`),
	check("disposed_items_unit_value_not_null", sql`NOT NULL unit_value`),
	check("disposed_items_total_value_not_null", sql`NOT NULL total_value`),
	check("disposed_items_disposal_date_not_null", sql`NOT NULL disposal_date`),
	check("disposed_items_approved_by_not_null", sql`NOT NULL approved_by`),
]);

export const transferItems = pgTable("transfer_items", {
	id: serial().primaryKey().notNull(),
	transferId: integer("transfer_id").notNull(),
	itemId: integer("item_id").notNull(),
	requestedQuantity: integer("requested_quantity").notNull(),
	approvedQuantity: integer("approved_quantity"),
	actualQuantity: integer("actual_quantity"),
	condition: text().default('good'),
	notes: text(),
	itemStatus: text("item_status"),
	isDisposed: boolean("is_disposed").default(false),
	disposalDate: timestamp("disposal_date", { mode: 'string' }),
	disposalReason: text("disposal_reason"),
}, (table) => [
	check("transfer_items_id_not_null", sql`NOT NULL id`),
	check("transfer_items_transfer_id_not_null", sql`NOT NULL transfer_id`),
	check("transfer_items_item_id_not_null", sql`NOT NULL item_id`),
	check("transfer_items_requested_quantity_not_null", sql`NOT NULL requested_quantity`),
]);
